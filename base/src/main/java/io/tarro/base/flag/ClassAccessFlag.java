/*
 * MIT License
 *
 * Copyright (c) 2018 Victor Schappert
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package io.tarro.base.flag;

import io.tarro.base.ClassFileVersion;

import java.util.List;

import static io.tarro.base.ClassFileVersion.JAVA1;
import static io.tarro.base.ClassFileVersion.JAVA5;
import static io.tarro.base.ClassFileVersion.JAVA6;
import static io.tarro.base.ClassFileVersion.JAVA9;
import static io.tarro.base.flag.FlagMixRule.ifFirstThenAlsoSecond;
import static io.tarro.base.flag.FlagMixRule.ifFirstThenNoneOfTheRest;
import static io.tarro.base.flag.FlagMixRule.notBothOf;
import static io.tarro.base.flag.FlagMixRule.rule;

/**
 * Enumerates the flags available in the top-level {@code access_flags} field of
 * a Java class file.
 *
 * @author Victor Schappert
 * @since 20171014
 * @see InnerClassAccessFlag
 */
public enum ClassAccessFlag implements Flag {

    //
    // ENUMERATORS
    //

    /**
     * {@code 0x0001} ({@code ACC_PUBLIC}): Indicates the class is declared
     * {@code public} and may be accessed from outside its package.
     */
    PUBLIC(0x0001),
    /**
     * {@code 0x0010} ({@code ACC_FINAL}): Indicates the class is declared
     * {@code final} and may not be subclassed.
     */
    FINAL(0x010),
    /**
     * <p>
     * {@code 0x0020} ({@code ACC_SUPER}): Indicates superclass methods should
     * be treated specially when invoked by the
     * {@link io.tarro.base.bytecode.OneOperandOpcode#INVOKESPECIAL
     * invokespecial} instruction.
     * </p>
     *
     * <p>
     * The {@code ACC_SUPER} flag exists for backward compatibility reasons
     * only. In Java 8 and above, the JVM considers the flag to be set in every
     * class file regardless of the actual value of the flag in the class file
     * <em>and regardless of the version of the class file</em>.
     * </p>
     */
    SUPER(0x0020),
    /**
     * {@code 0x200} ({@code ACC_INTERFACE}): Indicates that the class file
     * represents an interface&mdash;or possibly an annotation type&mdash;not a
     * class or module.
     */
    INTERFACE(0x200),
    /**
     * {@code 0x0400} ({@code ACC_ABSTRACT}): Indicates that the class was
     * declared abstract and must not be instantiated.
     */
    ABSTRACT(0x400),
    /**
     * {@code 0x1000} ({@code ACC_SYNTHETIC}): Indicates that the class is
     * synthetic, meaning it was generated by a compiler or similar program and
     * is not present in the source code.
     *
     * @see io.tarro.base.attribute.AttributeType#SYNTHETIC
     */
    SYNTHETIC(0x1000, JAVA5),
    /**
     * {@code 0x2000} ({@code ACC_ANNOTATION}): Indicates that the class file
     * represents an annotation type.
     */
    ANNOTATION(0x2000, JAVA5),
    /**
     * {@code 0x4000} ({@code ACC_ENUM}): Indicates that the class was declared
     * as an {@code enum} type.
     */
    ENUM(0x4000, JAVA5),
    /**
     * {@code 0x8000} ({@code ACC_MODULE}): Indicates that the class file
     * represents a module, not a class or interface.
     */
    MODULE(0x8000, JAVA9);

    //
    // DATA
    //

    private final int value;
    private final ClassFileVersion classFileVersion;

    //
    // CONSTRUCTORS
    //

    ClassAccessFlag(final int value, final ClassFileVersion classFileVersion) {
        this.value = value;
        this.classFileVersion = classFileVersion;
    }

    ClassAccessFlag(final int value) {
        this(value, JAVA1);
    }

    //
    // INTERFACE: Flag
    //

    @Override
    public String getFlagName() {
        return "ACC_" + name();
    }

    //
    // INTERFACE: Valued
    //

    /**
     * {@inheritDoc}
     *
     * <p>
     * This method returns the individual flag's integer value, which is
     * guaranteed to be a power of two distinct from any other flag in the
     * enumeration, since the {@code access_flags} member of class file is a
     * bitmask.
     * </p>
     *
     * @return Flag bit
     */
    @Override
    public int getValue() {
        return value;
    }

    //
    // INTERFACE: Versioned
    //

    @Override
    public ClassFileVersion getFirstVersionSupporting() {
        return classFileVersion;
    }

    //
    // PUBLIC CONSTANTS
    //

    /**
     * <p>
     * Obtains the "basic" rules about which class access flags may be mixed
     * together.
     * </p>
     *
     * <p>
     * The "basic" rules are the rules that have been in place <em>and enforced
     * in practice</em> by the JVM since {@linkplain ClassFileVersion#JAVA1 Java
     * 1} and that continue to apply across all Java versions.
     * </p>
     *
     * <p>
     * Note that the rules returned by this method are the same as the rules in
     * the first entry in the list returned by the {@link #allRules()} method.
     * </p>
     *
     * @return Basic flag mixing rules in force since Java 1
     * @see #allRules()
     */
    public static VersionedFlagMixRuleCollection<ClassAccessFlag> basicRules() {
        // Thread-safe despite the appearance of a race condition involving a
        // static variable because makeBasicRules() is idempotent and we don't
        // care if we do marginal amounts of extra work in unlikely corner
        // cases.
        if (null != BASIC_RULES) {
            return BASIC_RULES;
        } else {
            return BASIC_RULES = new VersionedFlagMixRuleCollection<>(JAVA1, makeBasicRules());
        }
    }

    /**
     * <p>
     * Obtains the complete list of rules about which class access flags may be
     * mixed together, segmented by class file version and in ascending order
     * by class file version.
     * </p>
     *
     * <p>
     * The list returned is non-empty and its first element is equivalent to the
     * value returned by {@link #basicRules()}. The rule collections in the
     * returned list are sorted in ascending order of Java class file version.
     * </p>
     *
     * @return All known flag mixing rules, grouped and sorted by class file
     *         version
     * @see #basicRules()
     */
    public static List<VersionedFlagMixRuleCollection<ClassAccessFlag>> allRules() {
        // Thread-safe despite the appearance of a race condition involving a
        // static variable because all the methods called are idempotent and we
        // don't care if we do marginal amounts of extra work in unlikely corner
        // cases.
        if (null != ALL_RULES) {
            return ALL_RULES;
        } else {
            return ALL_RULES = List.of(
                basicRules(),
                new VersionedFlagMixRuleCollection<>(JAVA5, makeIncrementalRulesForJava5()),
                new VersionedFlagMixRuleCollection<>(JAVA6, makeIncrementalRulesForJava6()),
                new VersionedFlagMixRuleCollection<>(JAVA9, makeIncrementalRulesForJava9())
            );
        }
    }

    //
    // INTERNALS
    //

    private static VersionedFlagMixRuleCollection<ClassAccessFlag> BASIC_RULES;

    @SuppressWarnings({"rawtypes", "unchecked"})
    private static FlagMixRule<ClassAccessFlag>[] makeBasicRules() {
        return new FlagMixRule[] {
                notBothOf("a class", FINAL, ABSTRACT),
                ifFirstThenNoneOfTheRest("a class", INTERFACE, FINAL, SUPER),
        };
    }

    private static List<VersionedFlagMixRuleCollection<ClassAccessFlag>> ALL_RULES;

    @SuppressWarnings({"rawtypes", "unchecked"})
    private static FlagMixRule<ClassAccessFlag>[] makeIncrementalRulesForJava5() {
        return new FlagMixRule[] {
                ifFirstThenAlsoSecond("a class", ANNOTATION, INTERFACE),
                notBothOf("a class", INTERFACE, ENUM)
        };
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    private static FlagMixRule<ClassAccessFlag>[] makeIncrementalRulesForJava6() {
        // Based on the Java virtual machine specification, one would expect the
        // rule `ifFirstThenAlsoSecond("a class", INTERFACE, ABSTRACT)` to be
        // part of the "basic" rule set. However, while that rule has
        // *technically* existed since Java 1.0.2, it only started being
        // *enforced* in Java 6, so we don't include it in the base rule set.
        //     See: https://stackoverflow.com/a/47871486/1911388
        return new FlagMixRule[] {
                ifFirstThenAlsoSecond("a class", INTERFACE, ABSTRACT)
        };
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    private static FlagMixRule<ClassAccessFlag>[] makeIncrementalRulesForJava9() {
        return new FlagMixRule[]{
                rule(set -> set.contains(MODULE) && 1 < set.size(),
                        "If ACC_MODULE is set no other access_flags may be set at class level")
        };
    }
}
